/*
 감이 안올땐 예시부터
 102는
 102 + 1 + 2 = 105
 105의 생성자다
 10은 10 + 1 이니 11의 생성자
 11은 11 + 1 + 1이니 13의 생성자
 12는 12 + 1 + 2이니 15의 생성자
 13은 13 + 1 + 3이니 17의 생성자

 21은 21 + 2 + 1이니 24의 생성자
 22는 22 + 2 + 2이니 26의 생성자

 100은 100 + 1이니 101의 생성자
 101은 101 + 1 + 1이니 103의 생성자
 110은 110 + 1 + 1이니 112의 생성자

 n = a + b + c + 100a + 10b + c
 를 만족함(세자리수라면)
 n이 k+1 자리수라 가정하면
 n = (10^k + 1)a + (10^(k-1) + 1)b + ....

 그럼 k+1자리에 대해 0~9까지의 숫자를 넣어가면서 만들어보면 되는거니까
 시간복잡도는 O(10^(k+1))
 N이 최대 7자리이므로 2초안에 해결 가능
 -> 고민해봤지만 k라는 변수만큼의 중첩 for문이 필요하기에
 만들기가 불가능
 이때 생각을 바꿔서 Int -> 문자열 -> Int
 방식으로 부분합을 구할 수 있고
 위에서 알아낸 것처럼 모든 경우의 수를 시도해도 타임아웃이 나지 않으므로
 그냥 무식하게 다해보는게 답이라 판단하게 되었음

 이 문제의 교훈은 시간복잡도 조건을 잘 보고
 무식한 방법으로 해결이 가능하면 그렇게 해결해보는게 먼저라는 것
 */
import Foundation

let n = Int(readLine()!)!



func partSum(x: Int) -> Int {
    let stringX = Array(String(x))
    var sum = x
    for str in stringX {
        sum += Int(String(str))!
    }

    return sum
}
var answer = 0

for i in 1..<n {
    if partSum(x: i) == n {
        answer = i
        break
    }
}

print(answer)
